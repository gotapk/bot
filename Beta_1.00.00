from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse
from word2number import w2n
from buscar_desarrollo import buscar_desarrollo, obtener_info_desarrollos_coincidentes
from unidecode import unidecode
from twilio.twiml.messaging_response import MessagingResponse
from datetime import datetime, timedelta
import utils



load_dotenv()

# Crear la aplicaci√≥n Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en espa√±ol fuera de la funci√≥n
nlp_model = spacy.load('es_core_news_lg')


# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como par√°metro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como par√°metro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Funci√≥n para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminaci√≥n de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords

# Funci√≥n para verificar si un nombre de desarrollo es v√°lido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Funci√≥n para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos d√≠as', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Funci√≥n para obtener el desarrollo de inter√©s mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None

# Funci√≥n para verificar si un mensaje menciona informaci√≥n del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aqu√≠ se asume que los nombres se componen de palabras que comienzan con una letra may√∫scula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0


# Funci√≥n para obtener la faq correspondiente a un desarrollo de inter√©s
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def detectar_intenciones(pos_tags, message):
    # Realizar an√°lisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    
    # Realizar an√°lisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intenci√≥n del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'
    else:
        message = message.lower()
        
        # Detectar intenci√≥n de Compra o Adquisici√≥n
        palabras_clave_compra = ["comprar", "adquirir", "cotizaci√≥n", "precio", "disponibilidad"]
        if any(palabra in message for palabra in palabras_clave_compra):
            intencion = 'compra'

        # Detectar intenci√≥n de Solicitar Informaci√≥n Adicional
        palabras_clave_info = ["dime m√°s sobre", "necesito detalles de", "expl√≠came acerca de"]
        if any(palabra in message for palabra in palabras_clave_info):
            intencion = 'informacion_adicional'

        # Detectar intenci√≥n de Solicitar Asesor√≠a o Ayuda
        palabras_clave_asesoria = ["ayuda", "asesor√≠a", "dudas", "consultor√≠a", "asesor"]
        if any(palabra in message for palabra in palabras_clave_asesoria):
            intencion = 'asesoria'

        # Detectar intenci√≥n de Agendar una Cita o Visita
        palabras_clave_cita = ["cita", "visita", "concretar una reuni√≥n", "agenda"]
        if any(palabra in message for palabra in palabras_clave_cita):
            intencion = 'agendar_cita'

        # Detectar intenci√≥n de Expresi√≥n de Inter√©s en un Producto o Servicio
        palabras_clave_interes = ["me encanata", "es perfecto"]
        if any(palabra in message for palabra in palabras_clave_interes) and sentiment_score > 0.05 and not intencion:
            intencion = 'interes_producto'

        # Detectar intenci√≥n de Agradecimiento o Satisfacci√≥n
        palabras_clave_agradecimiento = ["gracias", "agradecido", "excelente servicio"]
        if any(palabra in message for palabra in palabras_clave_agradecimiento):
            intencion = 'agradecimiento'
        
        # Detectar intenci√≥n de Expresi√≥n de Desinter√©s
        palabras_clave_desinteres = ["no me gusto", "no me intereso", "no tengo", "sin inter√©s", "otro proyecto", "que me puedes decir de",]
        if any(palabra in message for palabra in palabras_clave_desinteres) and sentiment_score > -0.05 and not intencion:
            intencion = 'desinteres'


    return intencion

def generar_respuesta(intencion, ultimo_mensaje_cliente):

    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_bot√≥n = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, env√≠anos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_bot√≥n}"
        return respuesta   
    
def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares


def obtener_presupuesto(texto):
    # Buscar cualquier secuencia de d√≠gitos que pueda contener comas para separar miles
    match = re.search(r'\$?\d{1,3}(?:,\d{3})*(?:\.\d+)?', texto)
    if match:
        presupuesto = match.group().replace('$', '').replace(',', '')
        try:
            valor_presupuesto = float(presupuesto)
            if valor_presupuesto >= 100000:
                return valor_presupuesto
        except ValueError:
            pass
    return None


dia_cita = None
hora_cita = None

dia_en_es = {
    'monday': 'lunes',
    'tuesday': 'martes',
    'wednesday': 'mi√©rcoles',
    'thursday': 'jueves',
    'friday': 'viernes',
    'saturday': 's√°bado',
    'sunday': 'domingo'
}

def obtener_dia_hora_cita(message):
    global dia_cita, hora_cita

    doc = nlp_model(message)

    dias_semana = ["lunes", "martes", "mi√©rcoles", "jueves", "viernes", "s√°bado", "domingo", "miercoles", "sabado"]
    horas_positivas = ["am", "pm"]
    horas_keywords = ["ma√±ana", "tarde", "noche"]
    dias_keywords = ["hoy", "ma√±ana", "pasado ma√±ana", "fin de semana"]

    for ent in doc.ents:
        if ent.label_ == "DATE":
            dia_cita_en = ent.text
            if dia_cita_en:
                if dia_cita_en.lower() in dia_en_es:
                    dia_cita = dia_en_es[dia_cita_en.lower()]  # Traducir el d√≠a a espa√±ol si est√° en el diccionario
        elif ent.label_ == "TIME":
            hora_tokens = ent.text.split()
            if len(hora_tokens) == 2 and hora_tokens[1].lower() in horas_positivas:
                hora_cita = ent.text
            elif any(keyword in ent.text.lower() for keyword in horas_keywords):
                hora_cita = ent.text

    for keyword in dias_keywords:
        if keyword in message.lower():
            if keyword == "hoy":
                dia_cita_en = datetime.now().strftime("%A")
            elif keyword == "ma√±ana":
                dia_cita_en = (datetime.now() + timedelta(days=1)).strftime("%A")
            elif keyword == "pasado ma√±ana":
                dia_cita_en = (datetime.now() + timedelta(days=2)).strftime("%A")
            elif keyword == "fin de semana":
                dia_cita_en = "s√°bado" if datetime.now().weekday() < 5 else "domingo"


            if dia_cita_en.lower() in dia_en_es:
                dia_cita = dia_en_es[dia_cita_en.lower()]  # Traducir el d√≠a a espa√±ol si est√° en el diccionario
        # Diccionario de correspondencia entre abreviaturas y d√≠as de la semana
    correspondencia_dias = {
        "miercoles": "mi√©rcoles",
        "sabado": "s√°bado"
    }

    for keyword in dias_semana:
        if keyword in message.lower():
            # Usar directamente el d√≠a de la semana mencionado o su equivalente en el diccionario
            dia_cita = correspondencia_dias.get(keyword, keyword)

    
    """            
    for keyword in dias_semana:
        if keyword in message.lower():
            dia_cita = keyword  # Usar directamente el d√≠a de la semana mencionado
            """
    # Buscar patrones de hora en diferentes formatos
    hora_patterns = [
        r'\d{1,2}:\d{2}\s?(am|pm)?',
        r'\d{1,2}:(am|pm)?',
        r'\d{1,2}:\d{2}?',
        r'\d{1,2}',
    ]
    for pattern in hora_patterns:
        hora_match = re.search(pattern, message)
        if hora_match:
            hora_cita = hora_match.group()
            break  # Detenerse en el primer patr√≥n coincidente encontrado

    return dia_cita, hora_cita

def obtener_numero(message):
    # Diccionario de n√∫meros en espa√±ol
    numeros_en_espanol = {
        "un": 1, "una": 1, "uno": 1, "dos": 2, "tres": 3, "cuatro": 4, "cinco": 5,
        "seis": 6, "siete": 7, "ocho": 8, "nueve": 9, "diez": 10
    }
    
    numero = None
    palabras = message.split()
    
    # Intentar detectar n√∫mero en formato num√©rico
    for palabra in palabras:
        palabra_sin_puntuacion = palabra.replace(",", "").replace(".", "")  # Remover puntuaci√≥n
        if palabra_sin_puntuacion.isdigit():
            numero = int(palabra_sin_puntuacion)
            print(f"N√∫mero encontrado (formato num√©rico): {numero}")
            break  # Salir del bucle si se encuentra un n√∫mero
    
    # Si no se encontr√≥ un n√∫mero en formato num√©rico, buscar en el diccionario
    if numero is None:
        for palabra in palabras:
            palabra_lower = palabra.lower()
            if palabra_lower in numeros_en_espanol:
                numero = numeros_en_espanol[palabra_lower]
                print(f"N√∫mero encontrado (forma escrita): {numero} (palabra: {palabra})")
                break
    
    return numero
# Variables globales para almacenar la informaci√≥n del usuario
nombre_usuario = None
numero_telefono = None
contexto = None
ruta_archivo = None
ruta_archivo_temporal = ruta_archivo 
desarrollo_interesado = None
contexto_global = None
mucho_gusto = None


# Diccionario para relacionar la ruta del archivo con el desarrollo interesado
archivo_a_desarrollo = {
    'faq_desarrollos/faq_Sant_Maarten.json': 'Sant Ma√§rten Lofts',
    'faq_desarrollos/faq_kartesia.json': 'Kartesia Residencial',
    'faq_desarrollos/faq_Maria_jose.json': 'Mar√≠a Jos√© Living',
    'faq_desarrollos/faq_Soneto.json': 'Soneto Residencial',
    # Agrega m√°s elementos si tienes m√°s archivos y desarrollos asociados
}

def guardar_informacion_usuario(nombre, telefono, archivo, desarrollo, contexto):
    global nombre_usuario, numero_telefono, ruta_archivo, desarrollo_interesado, contexto_global, mucho_gusto

    # Actualizar las variables globales solo si a√∫n no tienen un valor asignado
    if nombre_usuario is None:
        nombre_usuario = nombre

    if numero_telefono is None:
        numero_telefono = telefono

    if ruta_archivo is None:
        ruta_archivo = archivo  # Solo establecer ruta_archivo si a√∫n no tiene un valor

    if desarrollo_interesado is None:
        desarrollo_interesado = desarrollo

    if mucho_gusto is None:
        mucho_gusto = mucho_gusto

    # Siempre asignar un valor a contexto_global, independientemente de su valor actual
    contexto_global = contexto
    print(f"contexto global: {contexto_global}")
    print(f"Contexto: {contexto}")

    if desarrollo_interesado is not None:
        print(f"El desarrollo interesado es: {desarrollo_interesado}")
    else:
        print("No se encontr√≥ desarrollo interesado para la ruta del archivo proporcionada.")

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo, mucho_gusto

    # Obtener el mensaje y el n√∫mero de tel√©fono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    if nombre_usuario is not None and ruta_archivo is not None:
        # Llamar directamente a la funci√≥n buscar_sentimientos
        respuesta = buscar_sentimientos(ruta_archivo, message, formatted_phone_number)
        
        return "OK"
    
    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)
    # Si ya se tiene la ruta de archivo, no es necesario llamar a obtener_contexto
            # Almacenar el nombre del cliente solo si no ha sido obtenido previamente
        if nombre_usuario is None:
            nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None
                # Si ya tenemos el nombre del usuario, pero no el desarrollo de inter√©s, preguntamos por el desarrollo

    # Obtener el saludo seg√∫n la hora actual
    saludo = obtener_saludo()
    if ruta_archivo is None:
        # Obtener el contexto solo si no se tiene ya la ruta de archivo
        contexto, ruta_archivo = obtener_contexto(message)
        desarrollo_interesado = archivo_a_desarrollo.get(ruta_archivo)
        ruta_archivo_temporal = ruta_archivo
        guardar_informacion_usuario(nombre_usuario, numero_telefono, ruta_archivo_temporal, desarrollo_interesado, contexto)

    if ruta_archivo is not None and nombre_usuario is not None:
          # Imprimir la ruta del archivo recibida como argumento
        # Cerrar el ciclo actual y solicitar m√°s informaci√≥n si es necesario
        mensaje_saludo = f"*{nombre_usuario}* {contexto_global}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK" 
    
    # Detecci√≥n de palabras clave y extracci√≥n de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

    # Si ya se tiene el desarrollo interesado, no se sobrescribe

    if ruta_archivo is not None and nombre_usuario is not None:
        # Caso 1: El cliente menciona su nombre y el proyecto interesado
        mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK"

    if ruta_archivo is not None and nombre_usuario is None:
        # Caso 2: El cliente menciona solo el proyecto interesado, pero no proporciona su nombre
        mensaje_saludo = f"{saludo}!üëãüèª Gracias por contactarnos y por tu inter√©s en nuestro desarrollo *{desarrollo_interesado}*."
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        solicitud_nombre = random.choice(formas_solicitud_nombre)
        send_whatsapp_message(formatted_phone_number, solicitud_nombre)
        return "OK"
        # Si ya tenemos el nombre del usuario, pero no el desarrollo de inter√©s, preguntamos por el desarrollo


    if nombre_usuario is not None and ruta_archivo is None and mucho_gusto is None:
            send_whatsapp_message(formatted_phone_number, f"Mucho gusto *{nombre_usuario}* üåü ¬øDe qu√© desarrollo te gustar√≠a recibir informaci√≥n? üè¢  \n\nSi no conoces el nombre del desarrollo, puedes preguntarme porüìçubicaciones cercanas o üí∞rangos de precio.")
            mucho_gusto = True
            message = "no_action"  # Establecer message como cadena vac√≠

    if nombre_usuario is not None and ruta_archivo is None and mucho_gusto is True:     
            
            doc = nlp_model(message)
            print(f"mensaje del usario:",message)
            #print(f"Resultado del an√°lisis del modelo de lenguaje: {doc}")
            entidades_nombradas = extract_entities(message, nlp_model)

            tokens_importantes = detect_keywords(message, nlp_model)

            ubicacion = None
            presupuesto = None
            recamaras = None
            banos = None
            estacionamientos = None


            if message.isdigit():
                presupuesto = int(message)
                print(f"Presupuesto encontrado: {presupuesto}")

            # Agregar las palabras clave como entidades nombradas
            for keyword in tokens_importantes:
                entidades_nombradas.append({'text': keyword, 'start': -1, 'end': -1, 'label': 'KEYWORD', 'lemma': keyword})

            else:
                for ent in entidades_nombradas:
                    print(f"Resultado del an√°lisis del modelo de lenguaje: {ent['text']}")
                    print(f"Entidades nombradas: {entidades_nombradas}")
                    
                    if any(word in ent['text'].lower().split() for word in ['ba√±os', 'ba√±o', 'bano']):
                        banos = obtener_numero(message)
                        #banos = obtener_numero(ent['text'])

                        print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'ba√±os': {banos}")
                    elif any(word in ent['text'].lower().split() for word in ['rec√°maras', 'rec√°mara', 'habitaciones', 'habitaci√≥n', 'recamara', 'recamaras']):
                        recamaras = obtener_numero(message)
                        #recamaras = obtener_numero(ent['text'])

                        print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'rec√°maras': {recamaras}")

                    elif any(word in ent['text'].lower().split() for word in ['estacionamientos', 'estacionamiento']):
                        estacionamientos = obtener_numero(message)
                        #estacionamientos = obtener_numero(ent['text'])
                        print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'estacionamientos': {estacionamientos}")

                    elif any(word in ent['text'].lower().split() for word in ['presupuesto', 'tengo']):
                        presupuesto = obtener_numero(message)
                        print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Presupuesto encontrado: {presupuesto}")

                    elif ent['label']:
                        ubicacion = ent['text']

                resultados_coincidentes = buscar_desarrollo(ubicacion, presupuesto, recamaras, banos, estacionamientos)

            if message == "no_action": # Comprueba si message no est√° vac√≠o despu√©s de eliminar espacios en blanco
                pass
            else:
                if resultados_coincidentes:
                    formatted_results = obtener_info_desarrollos_coincidentes(resultados_coincidentes)

                    message1 = f"Con mucho gusto *{nombre_usuario}*, encontr√© los siguientes desarrollos que podr√≠an interesarte:\n\n{formatted_results}"
                    send_whatsapp_message(formatted_phone_number, message1)

                    message2 = "Si te gustar√≠a recibir m√°s informaci√≥n de alguno, escribe el nombre y te brindar√© informaci√≥n m√°s detallada.üòÅ"
                    send_whatsapp_message(formatted_phone_number, message2)
                        # Verificar si message est√° vac√≠o antes de enviar el mensaje "Lo siento, no encontr√© desarrollos que coincidan con tu b√∫squeda."
                else:
                    send_whatsapp_message(formatted_phone_number, "Lo siento, no encontr√© desarrollos que coincidan con tu b√∫squeda.")

            return "OK"
                    
    if nombre_usuario is not None and ruta_archivo is not None:
        respuesta = buscar_sentimientos (ruta_archivo, message, formatted_phone_number)

        print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
        # Cerrar el ciclo actual y solicitar m√°s informaci√≥n si es necesario
        mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK"          

    solicitud_nombre = random.choice(formas_solicitud_nombre)
    mensaje_saludo = f"{obtener_saludo()}! üëãüèª¬°Gracias por comunicarte a Dise√±o y Gesti√≥n Inmobiliaria *expertos en vivienda vertical* üèóÔ∏èüèôÔ∏è {solicitud_nombre}"
    send_whatsapp_message(formatted_phone_number, mensaje_saludo)
    print(f"ruta archivo: {ruta_archivo}")
    print(f"Desarrollo interesado: {desarrollo_interesado}")
    print(f"nombre:  {nombre_usuario}")
    return "OK"

# Definir una variable para almacenar el sentimiento globalmente
sentimiento_global = None
print ("sentimiento_global=",sentimiento_global)

def buscar_sentimientos(ruta_archivo, message, formatted_phone_number):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    pos_tags = pos_tag(word_tokenize(message))
    intencion = detectar_intenciones(pos_tags, message)



contador_respuestas_contestar_faqs = 0  # Contador para llevar el registro de las respuestas de contestar_faqs
max_respuestas_contestar_faqs = 3  # N√∫mero m√°ximo de respuestas consecutivas de contestar_faqs

contador_no_respuestas_faqs = 0  # Contador para llevar el registro de las respuestas no encontradas en faqs
max_contador_no_respuestas_faqs = 5  # N√∫mero m√°ximo de respuestas no encontradas en faqs


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    global contador_respuestas_contestar_faqs, sentimiento_global, contador_no_respuestas_faqs

    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)
        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            send_whatsapp_message(formatted_phone_number, respuesta_chatgpt)

            # Aumentar el contador de respuestas contestar_faqs
            contador_respuestas_contestar_faqs += 1

            if contador_respuestas_contestar_faqs >= max_respuestas_contestar_faqs:
                contador_respuestas_contestar_faqs = 0  # Reiniciar el contador
                asesor_cita = f"*{nombre_usuario}* Veo que te gustar√≠a recibir m√°s informaci√≥n, ¬øpuedo comunicarte con un asesor o programarte una cita? üë®üèΩ‚Äçüíª"
                send_whatsapp_message(formatted_phone_number, asesor_cita)
                #sentimiento_global = "mandar_asesor"  # Cambiar la variable global para activar preguntar_por_asesor
                return asesor_cita


        # Si no se encontr√≥ ninguna respuesta v√°lida y no se encontr√≥ ning√∫n enlace
        if respuesta_encontrada is None:
            no_respuesta = "Lo siento, no entend√≠ la pregunta. ¬øC√≥mo te puedo apoyar? ‚ò∫Ô∏è"
            send_whatsapp_message(formatted_phone_number, no_respuesta)

            # Aumentar el contador de no respuestas en FAQs
            contador_no_respuestas_faqs += 1

            if contador_no_respuestas_faqs >= max_contador_no_respuestas_faqs:
                contador_no_respuestas_faqs = 0  # Reiniciar el contador
                capacidad = f"*{nombre_usuario}* Creo que mi capacidad de respuesta lleg√≥ a su l√≠mite.üíî ¬°No te preocupes! üòÅ Un asesor te contactar√° en breve para darte seguimiento. üë®üèΩ‚Äçüíª"
                send_whatsapp_message(formatted_phone_number, capacidad)
                sentimiento_global = "mandar_prospeccion"  # Cambiar la variable global para activar preguntar_por_asesor
                return capacidad

def buscar_sentimientos(ruta_archivo, message, formatted_phone_number):
    global sentimiento_global
    pos_tags = pos_tag(word_tokenize(message))
    intencion = detectar_intenciones(pos_tags, message)

    if sentimiento_global == 'agradecimiento':
        agradecimiento = "de nada"
        send_whatsapp_message(formatted_phone_number, agradecimiento)
        print("Estamos agradecidos")

    elif sentimiento_global in ['agendar_cita', 'interes_producto']:
        respuesta = agendar_cita(formatted_phone_number, message)
        print("Pasamos a preguntar asesor")

    elif sentimiento_global in ['compra', 'asesoria', 'informacion_adicional',]:
        respuesta = preguntar_por_asesor(formatted_phone_number, message)
        print("Pasamos a preguntar asesor")
    
    elif sentimiento_global == 'mandar_asesor':
        respuesta = mandar_asesor(formatted_phone_number, message)
        print("Pasamos a mandar_asesor")
    
    elif sentimiento_global == 'mandar_prospeccion':
        respuesta = mandar_prospeccion(formatted_phone_number, message)
        print("Pasamos a mandar_prospeccion")

    elif sentimiento_global == 'desinteres':
        respuesta = mandar_desinteres(formatted_phone_number, message)
        print("Pasamos a mandar_desinteres")


    else:
        if intencion == 'agradecimiento':
            agradecimiento = "de nada"
            
            send_whatsapp_message(formatted_phone_number, agradecimiento)
            print("Estamos agradecidos")

        elif intencion in ['agendar_cita', 'interes_producto']:
            pregunta_inicial = "¬øTe gustar√≠a agendar una cita? üóìÔ∏è "
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
            #respuesta = agendar_cita(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        elif intencion in ['compra', 'asesoria', 'informacion_adicional', 'asesor']:
            pregunta_inicial = f"¬øTe gustar√≠a hablar con un asesor üë®üèΩ‚Äçüíª sobre tu pr√≥xima inversi√≥n en {desarrollo_interesado} üè¢?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")
        
        elif intencion in ['compra', 'asesoria', 'informacion_adicional', 'asesor']:
            pregunta_inicial = f"¬øTe gustar√≠a hablar con un asesor üë®üèΩ‚Äçüíª sobre tu pr√≥xima inversi√≥n en {desarrollo_interesado} üè¢?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        elif intencion == 'mandar_asesor':
            sentimiento_global = intencion
            respuesta = mandar_asesor(formatted_phone_number, message)
            print("Cerrando funci√≥n mandar_asesor")

        elif intencion == 'mandar_prospeccion':
            sentimiento_global = intencion
            respuesta = mandar_prospeccion(formatted_phone_number, message)
            print("Cerrando funci√≥n mandar_prospeccion")

        elif intencion == 'desinteres':
            pregunta_inicial = f"¬øTe gustar√≠a hablar de otro de nuestros desarrollos üèóÔ∏èüèôÔ∏è?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        else:
            contestar_faqs(ruta_archivo, message, formatted_phone_number)


def agendar_cita(formatted_phone_number, message):
    global sentimiento_global

    print("Iniciando funci√≥n agendar_cita")
    respuesta_cliente = message
    print("respuesta del cliente=", respuesta_cliente)

    dia_cita, hora_cita = obtener_dia_hora_cita(message)
    print("dia_cita =", dia_cita)
    print("hora_cita =", hora_cita)  # Obtener valores de dia_cita y hora_cita
 

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si", "ok"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            pedir_hora_fecha = "¬øEn que d√≠a y horario te gustar√≠a programarla? üóìÔ∏è üïê"
            #send_whatsapp_message(formatted_phone_number, pedir_hora_fecha)
            
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            #respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            ayudarte_mas = "¬øPuedo ayudarte en algo m√°s?"
            send_whatsapp_message(formatted_phone_number, ayudarte_mas)
            
            sentimiento_global = None  # Resetear sentimiento_global a None
        else:
            print("No se reconoce ninguna intenci√≥n.")

    if dia_cita is None and hora_cita is  None:
        dia_hora_agenda = "¬øEn que d√≠a y horario te gustar√≠a programarla? üóìÔ∏è üïê"
        send_whatsapp_message(formatted_phone_number, dia_hora_agenda)
        print("preguntando por d√≠a:")

    if dia_cita is None and hora_cita is not None:
        dia_agenda = "¬øQu√© d√≠a te gustar√≠a agendar?üóìÔ∏è"
        send_whatsapp_message(formatted_phone_number, dia_agenda)
        print("preguntando por d√≠a:")

    if hora_cita is None and dia_cita is not None:
        hora_agenda = "¬øA qu√© hora te gustar√≠a agendar?üïê"
        send_whatsapp_message(formatted_phone_number, hora_agenda)
        print("preguntando por hora")

    if hora_cita is not None and dia_cita is not None:
        respuesta = f"Perfecto {nombre_usuario}, un asesor se pondra en contacto contigo para confirmar tu cita para el d√≠a {dia_cita} a la(s) {hora_cita}üïê üóìÔ∏è"
        send_whatsapp_message(formatted_phone_number, respuesta)
        sentimiento_global = None  # Resetear sentimiento_global a None
        print("Agendado :3 no quiero saber nada xD")
    print("Finalizando funci√≥n agendar_cita")

def preguntar_por_asesor(formatted_phone_number, message):
    global sentimiento_global, ruta_archivo, contexto, contexto_global, desarrollo_interesado  # Declarar que se utilizar√° la variable global

    print("Iniciando funci√≥n preguntar_por_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias por tu inter√©s! Un asesor se pondr√° en contacto contigo prontoüë®üèΩ‚Äçüíª"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            #respuesta = preguntar_por_asesor(ruta_archivo, formatted_phone_number, message)
            respuesta = "¬øTe gustar√≠a recibir informaci√≥n de alg√∫n otro desarrollo? Invierte en preventa enüìçZona Centro Hist√≥rico üìçZona MinervaüìçZona Chapu üìçZona Barranca"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            # Resetear sentimiento_global a None
            sentimiento_global = None
            ruta_archivo = None  
            contexto = None
            contexto_global = None
            desarrollo_interesado = None
            
    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n preguntar_por_asesor")

def mandar_desinteres(formatted_phone_number, message):
    global sentimiento_global, ruta_archivo, contexto, contexto_global, desarrollo_interesado  # Declarar que se utilizar√° la variable global

    print("Iniciando funci√≥n preguntar_por_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            verificacion = f"*{nombre_usuario}* üåü ¬øDe qu√© desarrollo te gustar√≠a recibir informaci√≥n? üè¢  \n\nSi no conoces el nombre del desarrollo, puedes preguntarme porüìçubicaciones cercanas o üí∞rangos de precio."
            send_whatsapp_message(formatted_phone_number, verificacion)
            print("Respuesta positiva enviada:", verificacion)
            sentimiento_global = None
            ruta_archivo = None  
            contexto = None
            contexto_global = None
            desarrollo_interesado = None
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
                        #respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            ayudarte_mas = "¬øEn que m√°s te puedo ayudar?"
            send_whatsapp_message(formatted_phone_number, ayudarte_mas)
            
            sentimiento_global = None  # Resetear sentimiento_global a None
            
    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n preguntar_por_asesor")

def mandar_asesor (formatted_phone_number, message):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    print("Iniciando funci√≥n mandar_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias por tu inter√©s! üë®üèΩ‚Äçüíª Un asesor se pondr√° en contacto contigo pronto."
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            respuesta = "¬øEn qu√© m√°s puedo ayudarte?"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            sentimiento_global = None  # Resetear sentimiento_global a None

    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n mandar_asesor")

def mandar_prospeccion (formatted_phone_number, message):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    print("Iniciando funci√≥n mandar_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias! prospecci√≥n se pondr√° en contacto contigo pronto."
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            respuesta = "Lamentamos no poder ayudarte üò≠üò≠"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            sentimiento_global = None  # Resetear sentimiento_global a None

    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n mandar_asesor")

    
def generar_respuesta_chatgpt(message, respuesta_encontrada):

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"{respuesta_encontrada} \n\n{message} "
    print("ChatGPT est√° procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompt,
        temperature=1,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada

def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un n√∫mero de tel√©fono de WhatsApp v√°lido
        body=message,
        to='whatsapp:+5213328650226'  # N√∫mero de tel√©fono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)






----------------------------------------------------> Beta sin pipe drive <--------------------------------------------->>>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>

__________________- beta 1.10.01 -----------------------------------
from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse
from word2number import w2n
from buscar_desarrollo import buscar_desarrollo, obtener_info_desarrollos_coincidentes
from unidecode import unidecode
from twilio.twiml.messaging_response import MessagingResponse
from datetime import datetime, timedelta
import utils
import difflib
from unidecode import unidecode  # Importa la funci√≥n unidecode

from difflib import get_close_matches
from numeros_en_espanol import numeros_en_espanol, numeros_en_espanol_pequenos




load_dotenv()

# Crear la aplicaci√≥n Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en espa√±ol fuera de la funci√≥n
nlp_model = spacy.load('es_core_news_lg')


# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como par√°metro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como par√°metro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Funci√≥n para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminaci√≥n de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords

# Funci√≥n para verificar si un nombre de desarrollo es v√°lido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Funci√≥n para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos d√≠as', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Funci√≥n para obtener el desarrollo de inter√©s mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None

# Funci√≥n para verificar si un mensaje menciona informaci√≥n del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aqu√≠ se asume que los nombres se componen de palabras que comienzan con una letra may√∫scula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0


# Funci√≥n para obtener la faq correspondiente a un desarrollo de inter√©s
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def detectar_intenciones(pos_tags, message):
    # Realizar an√°lisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    
    # Realizar an√°lisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intenci√≥n del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'
    else:
        message = message.lower()
        
        # Detectar intenci√≥n de Compra o Adquisici√≥n
        palabras_clave_compra = ["comprar", "adquirir", "cotizaci√≥n", "precio", "disponibilidad"]
        if any(palabra in message for palabra in palabras_clave_compra):
            intencion = 'compra'

        # Detectar intenci√≥n de Solicitar Informaci√≥n Adicional
        palabras_clave_info = ["dime m√°s sobre", "necesito detalles de", "expl√≠came acerca de"]
        if any(palabra in message for palabra in palabras_clave_info):
            intencion = 'informacion_adicional'

        # Detectar intenci√≥n de Solicitar Asesor√≠a o Ayuda
        palabras_clave_asesoria = ["ayuda", "asesor√≠a", "dudas", "consultor√≠a", "asesor"]
        if any(palabra in message for palabra in palabras_clave_asesoria):
            intencion = 'asesoria'

        # Detectar intenci√≥n de Agendar una Cita o Visita
        palabras_clave_cita = ["cita", "visita", "concretar una reuni√≥n", "agenda"]
        if any(palabra in message for palabra in palabras_clave_cita):
            intencion = 'agendar_cita'

        # Detectar intenci√≥n de Expresi√≥n de Inter√©s en un Producto o Servicio
        palabras_clave_interes = ["me encanata", "es perfecto"]
        if any(palabra in message for palabra in palabras_clave_interes) and sentiment_score > 0.05 and not intencion:
            intencion = 'interes_producto'

        # Detectar intenci√≥n de Agradecimiento o Satisfacci√≥n
        palabras_clave_agradecimiento = ["gracias", "agradecido", "excelente servicio"]
        if any(palabra in message for palabra in palabras_clave_agradecimiento):
            intencion = 'agradecimiento'
        
        # Detectar intenci√≥n de Expresi√≥n de Desinter√©s
        palabras_clave_desinteres = ["no me gust√≥", "no me interes√≥", "no tengo", "sin inter√©s", "otro proyecto", "que me puedes decir de", "otro desarrollo", "desarrollo cerca"]
        if any(palabra in message for palabra in palabras_clave_desinteres):
            intencion = 'desinteres'
        
        # Detectar intenci√≥n de Expresi√≥n de Desinter√©s
        palabras_clave_desinteres = ["DyG", "DYG", "dise√±o y gesti√≥n", "inmobiliaria ", "desarrolladora", "quienes son", "dise√±o y gestion", "dyg", ]
        if any(palabra in message for palabra in palabras_clave_desinteres):
            intencion = 'diseno_gestion'

        # Detectar intenci√≥n de Expresi√≥n de Desinter√©s
        palabras_clave_desinteres = ["ubicado", "ubicaci√≥n", "donde estan", "donde se encuentran ", "direcci√≥n"]
        if any(palabra in message for palabra in palabras_clave_desinteres):
            intencion = 'diseno_gestion_ubicacion'
    return intencion

def generar_respuesta(intencion, ultimo_mensaje_cliente):

    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_bot√≥n = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, env√≠anos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_bot√≥n}"
        return respuesta  
    
def diseno_gestion(intencion):

    if intencion == 'diseno_gestion':
        respuesta = f"*Dise√±o y Gesti√≥n Inmobiliaria expertos en vivienda vertical 25 a√±os marcando diferencia en el sector inmobiliario*\n\n Desarrolladora con un portafolio de m√°s de 3,800 viviendas construidas, dedicada a la construcci√≥n de obra civil, tanto p√∫blica como privada, especializada en proyectos de vivienda vertical."
        return respuesta 
    
    if intencion == 'diseno_gestion_ubicacion':
        respuesta = f"puedes encontrar toda la informac√≥n de *dise√±o y gesti√≥n inmobiliaria* https://disenoygestion.mx/"
        return respuesta 
    
def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Convertir la pregunta actual, entidades nombradas y tokens importantes a min√∫sculas
        pregunta_actual = pregunta_actual.lower()
        entidades_nombradas_pregunta = [entidad.lower() for entidad in entidades_nombradas]
        tokens_importantes_pregunta = [token.lower() for token in tokens_importantes]
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_similares = [entidad for entidad in entidades_nombradas_pregunta if entidad in pregunta_actual]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_pregunta = [token.lower() for token in tokens_pregunta]  # Convertir tokens de la pregunta a min√∫sculas
        tokens_similares = [token for token in tokens_importantes_pregunta if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

    
"""def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares"""


def obtener_presupuesto(texto):
    # Buscar cualquier secuencia de d√≠gitos que pueda contener comas para separar miles
    match = re.search(r'\$?\d{1,3}(?:,\d{3})*(?:\.\d+)?', texto)
    if match:
        presupuesto = match.group().replace('$', '').replace(',', '')
        try:
            valor_presupuesto = float(presupuesto)
            if valor_presupuesto >= 100000:
                return valor_presupuesto
        except ValueError:
            pass
    return None


dia_cita = None
hora_cita = None

dia_en_es = {
    'monday': 'lunes',
    'tuesday': 'martes',
    'wednesday': 'mi√©rcoles',
    'thursday': 'jueves',
    'friday': 'viernes',
    'saturday': 's√°bado',
    'sunday': 'domingo'
}

def obtener_dia_hora_cita(message):
    global dia_cita, hora_cita

    doc = nlp_model(message)

    dias_semana = ["lunes", "martes", "mi√©rcoles", "jueves", "viernes", "s√°bado", "domingo", "miercoles", "sabado"]
    horas_positivas = ["am", "pm"]
    horas_keywords = ["ma√±ana", "tarde", "noche"]
    dias_keywords = ["hoy", "ma√±ana", "pasado ma√±ana", "fin de semana"]

    for ent in doc.ents:
        if ent.label_ == "DATE":
            dia_cita_en = ent.text
            if dia_cita_en:
                if dia_cita_en.lower() in dia_en_es:
                    dia_cita = dia_en_es[dia_cita_en.lower()]  # Traducir el d√≠a a espa√±ol si est√° en el diccionario
        elif ent.label_ == "TIME":
            hora_tokens = ent.text.split()
            if len(hora_tokens) == 2 and hora_tokens[1].lower() in horas_positivas:
                hora_cita = ent.text
            elif any(keyword in ent.text.lower() for keyword in horas_keywords):
                hora_cita = ent.text

    for keyword in dias_keywords:
        if keyword in message.lower():
            if keyword == "hoy":
                dia_cita_en = datetime.now().strftime("%A")
            elif keyword == "ma√±ana":
                dia_cita_en = (datetime.now() + timedelta(days=1)).strftime("%A")
            elif keyword == "pasado ma√±ana":
                dia_cita_en = (datetime.now() + timedelta(days=2)).strftime("%A")
            elif keyword == "fin de semana":
                dia_cita_en = "s√°bado" if datetime.now().weekday() < 5 else "domingo"


            if dia_cita_en.lower() in dia_en_es:
                dia_cita = dia_en_es[dia_cita_en.lower()]  # Traducir el d√≠a a espa√±ol si est√° en el diccionario
        # Diccionario de correspondencia entre abreviaturas y d√≠as de la semana
    correspondencia_dias = {
        "miercoles": "mi√©rcoles",
        "sabado": "s√°bado"
    }

    for keyword in dias_semana:
        if keyword in message.lower():
            # Usar directamente el d√≠a de la semana mencionado o su equivalente en el diccionario
            dia_cita = correspondencia_dias.get(keyword, keyword)

    
    """            
    for keyword in dias_semana:
        if keyword in message.lower():
            dia_cita = keyword  # Usar directamente el d√≠a de la semana mencionado
            """
    # Buscar patrones de hora en diferentes formatos
    hora_patterns = [
        r'\d{1,2}:\d{2}\s?(am|pm)?',
        r'\d{1,2}:(am|pm)?',
        r'\d{1,2}:\d{2}?',
        r'\d{1,2}',
    ]
    for pattern in hora_patterns:
        hora_match = re.search(pattern, message)
        if hora_match:
            hora_cita = hora_match.group()
            break  # Detenerse en el primer patr√≥n coincidente encontrado

    return dia_cita, hora_cita



numeros_en_espanol_normalized = {unidecode(clave.lower()): valor for clave, valor in numeros_en_espanol.items()}
 
def verificar_similitud_presupuesto_en_mensaje(texto):
    texto = unidecode(texto.replace("$", "").replace(",", "")).lower()  # Normaliza el texto sin acentos
    numeros = numeros_en_espanol_normalized.keys()
    matches = []

    for numero in numeros:
        if numero in texto:
            matches.append(numero)

    if matches:
        match = max(matches, key=len)  # Escoge la coincidencia m√°s larga
        presupuesto_encontrado = numeros_en_espanol_normalized[match]
        return presupuesto_encontrado
    


numeros_en_espanol_lower = {clave.lower(): valor for clave, valor in numeros_en_espanol.items()}

def verificar_presupuesto_en_mensaje(text):
    # Aplicar transformaci√≥n al mensaje para eliminar s√≠mbolo de precios y comas
    text = text.replace("$", "").replace(",", "").lower()
    
    numeros = numeros_en_espanol_lower.keys()
    matches = get_close_matches(text, numeros, n=1, cutoff=0.8)
    
    if matches:
        match = matches[0]
        numero_obtenido = numeros_en_espanol_lower[match]
        print(f"N√∫mero obtenido del diccionario: {numero_obtenido}")
        return numero_obtenido
    
    # Obtener las palabras del mensaje
    palabras = text.split()

    # Verificar si alguna palabra del mensaje est√° en el diccionario y es mayor o igual a 100000
    presupuesto_encontrado = any(
        palabra in numeros_en_espanol_lower and numeros_en_espanol_lower[palabra] >= 100000
        for palabra in palabras
    )
    
    return presupuesto_encontrado


"""def verificar_presupuesto_en_mensaje(message):

    message = message.replace("$", "").replace(",", "").lower()
    
    numeros = numeros_en_espanol_lower.keys()
    matches = get_close_matches(message, numeros, n=1, cutoff=0.8)
    
    if matches:
        match = matches[0]
        numero_obtenido = numeros_en_espanol_lower[match]
        print (f"numero obtenido",numero_obtenido)
        return numero_obtenido

    # Obtener las palabras del mensaje
    palabras = message.split()

    # Verificar si alguna palabra del mensaje est√° en el diccionario y es mayor o igual a 100000
    presupuesto_encontrado = any(
        palabra in numeros_en_espanol_lower and numeros_en_espanol_lower[palabra] >= 100000
        for palabra in palabras
    )
    
    return presupuesto_encontrado"""


def obtener_numero(message):
    # Diccionario de n√∫meros en espa√±ol

    
    numero = None
    palabras = message.split()
    
    # Intentar detectar n√∫mero en formato num√©rico
    for palabra in palabras:
        palabra_sin_puntuacion = palabra.replace(",", "").replace(".", "")  # Remover puntuaci√≥n
        if palabra_sin_puntuacion.isdigit():
            numero = int(palabra_sin_puntuacion)
            print(f"N√∫mero encontrado (formato num√©rico): {numero}")
            break  # Salir del bucle si se encuentra un n√∫mero
    
    # Si no se encontr√≥ un n√∫mero en formato num√©rico, buscar en el diccionario
    if numero is None:
        for palabra in palabras:
            palabra_lower = palabra.lower()
            if palabra_lower in numeros_en_espanol_pequenos:
                numero = numeros_en_espanol_pequenos[palabra_lower]
                print(f"N√∫mero encontrado (forma escrita): {numero} (palabra: {palabra})")
                break
    
    return numero

# Variables globales para almacenar la informaci√≥n del usuario
nombre_usuario = None
numero_telefono = None
contexto = None
ruta_archivo = None
ruta_archivo_temporal = ruta_archivo 
desarrollo_interesado = None
contexto_global = None
mucho_gusto = None


# Diccionario para relacionar la ruta del archivo con el desarrollo interesado
archivo_a_desarrollo = {
    'faq_desarrollos/faq_Sant_Maarten.json': 'Sant Ma√§rten Lofts',
    'faq_desarrollos/faq_kartesia.json': 'Kartesia Residencial',
    'faq_desarrollos/faq_Maria_jose.json': 'Mar√≠a Jos√© Living',
    'faq_desarrollos/faq_Soneto.json': 'Soneto Residencial',
    # Agrega m√°s elementos si tienes m√°s archivos y desarrollos asociados
}

def guardar_informacion_usuario(nombre, telefono, archivo, desarrollo, contexto):
    global nombre_usuario, numero_telefono, ruta_archivo, desarrollo_interesado, contexto_global, mucho_gusto

    # Actualizar las variables globales solo si a√∫n no tienen un valor asignado
    if nombre_usuario is None:
        nombre_usuario = nombre

    if numero_telefono is None:
        numero_telefono = telefono

    if ruta_archivo is None:
        ruta_archivo = archivo  # Solo establecer ruta_archivo si a√∫n no tiene un valor

    if desarrollo_interesado is None:
        desarrollo_interesado = desarrollo

    if mucho_gusto is None:
        mucho_gusto = mucho_gusto

    # Siempre asignar un valor a contexto_global, independientemente de su valor actual
    contexto_global = contexto
    print(f"contexto global: {contexto_global}")
    print(f"Contexto: {contexto}")

    if desarrollo_interesado is not None:
        print(f"El desarrollo interesado es: {desarrollo_interesado}")
    else:
        print("No se encontr√≥ desarrollo interesado para la ruta del archivo proporcionada.")

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo, mucho_gusto

    # Obtener el mensaje y el n√∫mero de tel√©fono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))


    
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'diseno_gestion':
        respuesta = diseno_gestion(detectar_intenciones(pos_tags, message))
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    if nombre_usuario is not None and ruta_archivo is not None:
        # Llamar directamente a la funci√≥n buscar_sentimientos
        respuesta = buscar_sentimientos(ruta_archivo, message, formatted_phone_number)
        
        return "OK"
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'diseno_gestion_ubicacion':
        respuesta = diseno_gestion(detectar_intenciones(pos_tags, message))
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)
    # Si ya se tiene la ruta de archivo, no es necesario llamar a obtener_contexto
            # Almacenar el nombre del cliente solo si no ha sido obtenido previamente
        if nombre_usuario is None:
            nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None
                # Si ya tenemos el nombre del usuario, pero no el desarrollo de inter√©s, preguntamos por el desarrollo

    # Obtener el saludo seg√∫n la hora actual
    saludo = obtener_saludo()
    if ruta_archivo is None:
        # Obtener el contexto solo si no se tiene ya la ruta de archivo
        contexto, ruta_archivo = obtener_contexto(message)
        desarrollo_interesado = archivo_a_desarrollo.get(ruta_archivo)
        ruta_archivo_temporal = ruta_archivo
        guardar_informacion_usuario(nombre_usuario, numero_telefono, ruta_archivo_temporal, desarrollo_interesado, contexto)

    if ruta_archivo is not None and nombre_usuario is not None:
          # Imprimir la ruta del archivo recibida como argumento
        # Cerrar el ciclo actual y solicitar m√°s informaci√≥n si es necesario
        mensaje_saludo = f"*{nombre_usuario}* {contexto_global}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK" 
    
    # Detecci√≥n de palabras clave y extracci√≥n de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

    # Si ya se tiene el desarrollo interesado, no se sobrescribe

    if ruta_archivo is not None and nombre_usuario is not None:
        # Caso 1: El cliente menciona su nombre y el proyecto interesado
        mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK"

    if ruta_archivo is not None and nombre_usuario is None:
        # Caso 2: El cliente menciona solo el proyecto interesado, pero no proporciona su nombre
        mensaje_saludo = f"{saludo}!üëãüèª Gracias por contactarnos y por tu inter√©s en nuestro desarrollo *{desarrollo_interesado}*."
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        solicitud_nombre = random.choice(formas_solicitud_nombre)
        send_whatsapp_message(formatted_phone_number, solicitud_nombre)
        return "OK"
        # Si ya tenemos el nombre del usuario, pero no el desarrollo de inter√©s, preguntamos por el desarrollo


    if nombre_usuario is not None and ruta_archivo is None and mucho_gusto is None:
            send_whatsapp_message(formatted_phone_number, f"Mucho gusto *{nombre_usuario}* üåü ¬øDe qu√© desarrollo te gustar√≠a recibir informaci√≥n? üè¢  \n\nSi no conoces el nombre del desarrollo, puedes preguntarme porüìçubicaciones cercanas o üí∞rangos de precio.")
            mucho_gusto = True
            message = "no_action"  # Establecer message como cadena vac√≠

    if nombre_usuario is not None and ruta_archivo is None and mucho_gusto is True:     
            
            doc = nlp_model(message)
            print(f"mensaje del usario:",message)
            #print(f"Resultado del an√°lisis del modelo de lenguaje: {doc}")
            entidades_nombradas = extract_entities(message, nlp_model)

            tokens_importantes = detect_keywords(message, nlp_model)
            # Aplicar transformaci√≥n al mensaje para eliminar s√≠mbolo de precios y comas
            message = message.replace("$", "").replace(",", "").lower()

            ubicacion = None
            presupuesto = None
            recamaras = None
            banos = None
            estacionamientos = None
            print(f"presupuesto que llega a la variable:", presupuesto)

            if message :
                presupuesto = verificar_presupuesto_en_mensaje(message)
                print(f"Tiene presupuesto mayor o igual a 100000 1: {presupuesto}")
                print(f"presupuesto que llega a la variable if message:", presupuesto)
             
                if message.isdigit():
                    presupuesto = int(message)
                    print(f"Presupuesto encontrado: {presupuesto}")
                    print(f"presupuesto que llega a la variable:", presupuesto)
                
            
            """if any(word in message.lower().split() for word in ['presupuesto', 'tengo']):
                presupuesto = verificar_similitud_presupuesto_en_mensaje(message) 
                print(f"Tiene presupuesto mayor o igual a 100000 2: {presupuesto}")"""


            # Agregar las palabras clave como entidades nombradas
            for keyword in tokens_importantes:
                entidades_nombradas.append({'text': keyword, 'start': -1, 'end': -1, 'label': 'KEYWORD', 'lemma': keyword})
                
                #ent_text_lower = ent['text'].lower()  # Convertir el texto de la entidad a min√∫sculas

            else:
                for ent in entidades_nombradas:
                    #print(f"Resultado del an√°lisis del modelo de lenguaje: {ent['text']}")
                    #print(f"Entidades nombradas: {entidades_nombradas}")
                    
                    if any(word in ent['text'].lower().split() for word in ['ba√±os', 'ba√±o', 'bano']):
                        banos = obtener_numero(message)
                        #banos = obtener_numero(ent['text'])

                        #print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'ba√±os': {banos}")
                    elif any(word in ent['text'].lower().split() for word in ['rec√°maras', 'rec√°mara', 'habitaciones', 'habitaci√≥n', 'recamara', 'recamaras']):
                        recamaras = obtener_numero(message)
                        #recamaras = obtener_numero(ent['text'])

                        #print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'rec√°maras': {recamaras}")

                    elif any(word in ent['text'].lower().split() for word in ['estacionamientos', 'estacionamiento']):
                        estacionamientos = obtener_numero(message)
                        #estacionamientos = obtener_numero(ent['text'])
                       # print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                        print(f"Encontrado 'estacionamientos': {estacionamientos}")

                    
                    elif any(word in ent['text'].lower().split() for word in ['presupuesto', 'tengo']):
                        presupuesto_verificado = verificar_similitud_presupuesto_en_mensaje(message)
                        presupuesto = obtener_numero(message)
                        
                        if presupuesto_verificado:
                            presupuesto = presupuesto_verificado
                            print(f"Texto de entidad: {ent['text']}")
                            print(f"Presupuesto verificado encontrado: {presupuesto_verificado}")
                        
                            if presupuesto:
                                print(f"Texto de entidad: {ent['text']}")
                                print(f"Presupuesto num√©rico encontrado: {presupuesto}")
                    
                 #   elif any(word in ent['text'].lower().split() for word in ['presupuesto', 'tengo']):
                  #      presupuesto = verificar_similitud_presupuesto_en_mensaje(message)
                   #     print(f"Texto de entidad: {ent['text']}")
                    #    print(f"Presupuesto encontrado: {presupuesto}")
                        

                        
                #    elif any(word in ent['text'].lower().split() for word in ['presupuesto', 'tengo']):
                 #       presupuesto = obtener_numero(message)
                  #      print(f"Texto de entidad: {ent['text']}")  # Agregar esta l√≠nea para mostrar el texto de la entidad
                   #     print(f"Presupuesto encontrado: {presupuesto}")
                #        if presupuesto == 0:  # Verifica si no se encontr√≥ un presupuesto v√°lido
                 #           presupuesto = verificar_similitud_presupuesto_en_mensaje(message)
                  #          print(f"Tiene presupuesto mayor o igual a 100000 3: {presupuesto}")

                    


                    elif ent['label']:
                        ubicacion = ent['text']

                resultados_coincidentes = buscar_desarrollo(ubicacion, presupuesto, recamaras, banos, estacionamientos)

            if message == "no_action": # Comprueba si message no est√° vac√≠o despu√©s de eliminar espacios en blanco
                pass
            else:
                if resultados_coincidentes:
                    formatted_results = obtener_info_desarrollos_coincidentes(resultados_coincidentes)

                    message1 = f"Con mucho gusto *{nombre_usuario}*, encontr√© los siguientes desarrollos que podr√≠an interesarte:\n\n{formatted_results}"
                    send_whatsapp_message(formatted_phone_number, message1)

                    message2 = "Si te gustar√≠a recibir m√°s informaci√≥n de alguno, escribe el nombre y te brindar√© informaci√≥n m√°s detallada.üòÅ"
                    send_whatsapp_message(formatted_phone_number, message2)
                        # Verificar si message est√° vac√≠o antes de enviar el mensaje "Lo siento, no encontr√© desarrollos que coincidan con tu b√∫squeda."
                else:
                    send_whatsapp_message(formatted_phone_number, "Lo siento, no encontr√© desarrollos que coincidan con tu b√∫squeda.")

            return "OK"
                    
    if nombre_usuario is not None and ruta_archivo is not None:
        respuesta = buscar_sentimientos (ruta_archivo, message, formatted_phone_number)

        print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
        # Cerrar el ciclo actual y solicitar m√°s informaci√≥n si es necesario
        mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
        send_whatsapp_message(formatted_phone_number, mensaje_saludo)
        send_whatsapp_message(formatted_phone_number, f"¬øQu√© te gustar√≠a conocer m√°s de *{desarrollo_interesado}*? ¬øSus amenidades o modelos disponibles?")
        return "OK"          

    solicitud_nombre = random.choice(formas_solicitud_nombre)
    mensaje_saludo = f"{obtener_saludo()}! üëãüèª¬°Gracias por comunicarte a Dise√±o y Gesti√≥n Inmobiliaria *expertos en vivienda vertical* üèóÔ∏èüèôÔ∏è {solicitud_nombre}"
    send_whatsapp_message(formatted_phone_number, mensaje_saludo)
    print(f"ruta archivo: {ruta_archivo}")
    print(f"Desarrollo interesado: {desarrollo_interesado}")
    print(f"nombre:  {nombre_usuario}")
    return "OK"

# Definir una variable para almacenar el sentimiento globalmente
sentimiento_global = None


def buscar_sentimientos(ruta_archivo, message, formatted_phone_number):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    pos_tags = pos_tag(word_tokenize(message))
    intencion = detectar_intenciones(pos_tags, message)
    print ("sentimiento_global=",sentimiento_global)


contador_respuestas_contestar_faqs = 0  # Contador para llevar el registro de las respuestas de contestar_faqs
max_respuestas_contestar_faqs = 5 # N√∫mero m√°ximo de respuestas consecutivas de contestar_faqs
contador_mediumrespuestas_contestar_faqs = 0
mediumrespuestas_contestar_faqs = 3 # N√∫mero medio de respuestas consecutivas de contestar_faqs

contador_no_respuestas_faqs = 0  # Contador para llevar el registro de las respuestas no encontradas en faqs
max_contador_no_respuestas_faqs = 5  # N√∫mero m√°ximo de respuestas no encontradas en faqs


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    global contador_respuestas_contestar_faqs, sentimiento_global, contador_no_respuestas_faqs, contador_mediumrespuestas_contestar_faqs
    print("Valor actual de contador_respuestas_contestar_faqs:", contador_respuestas_contestar_faqs)
    print("Valor actual de mediumrespuestas_contestar_faqs:", contador_mediumrespuestas_contestar_faqs)
    print("Valor actual de contador_no_respuestas_faqs:", contador_no_respuestas_faqs)

    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

                # Convertir el mensaje y las preguntas a min√∫sculas
        message = message.lower()
        preguntas_respuestas_lower = [
            {'preguntas': [pregunta.lower() for pregunta in item['preguntas']], 'respuesta': item['respuesta']}
            for item in preguntas_respuestas
        ]

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)
        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            send_whatsapp_message(formatted_phone_number, respuesta_chatgpt)

            # Aumentar el contador de respuestas contestar_faqs
            contador_respuestas_contestar_faqs += 1
            contador_mediumrespuestas_contestar_faqs += 1
            print("Contadores incrementados")

            if contador_mediumrespuestas_contestar_faqs == mediumrespuestas_contestar_faqs:
                brochure_financiamiento = "tambien te puedo apoyar con el brochure o los metodos de fimnanciamiento "
                send_whatsapp_message(formatted_phone_number, brochure_financiamiento)


            if contador_respuestas_contestar_faqs == max_respuestas_contestar_faqs:
                contador_respuestas_contestar_faqs = 0  # Reiniciar el contador
                contador_no_respuestas_faqs = 0
                contador_mediumrespuestas_contestar_faqs = 0  # Reiniciar el contador
                asesor_cita = f"*{nombre_usuario}* Veo que te gustar√≠a recibir m√°s informaci√≥n, ¬øpuedo comunicarte con un asesor o programarte una cita? üë®üèΩ‚Äçüíª"
                send_whatsapp_message(formatted_phone_number, asesor_cita)
                #sentimiento_global = "mandar_asesor"  # Cambiar la variable global para activar preguntar_por_asesor
                return asesor_cita


        # Si no se encontr√≥ ninguna respuesta v√°lida y no se encontr√≥ ning√∫n enlace
        if respuesta_encontrada is None:
            no_respuesta = "Lo siento, no entend√≠ la pregunta. ¬øC√≥mo te puedo apoyar? ‚ò∫Ô∏è"
            send_whatsapp_message(formatted_phone_number, no_respuesta)

            # Aumentar el contador de no respuestas en FAQs
            contador_no_respuestas_faqs += 1

            if contador_no_respuestas_faqs == max_contador_no_respuestas_faqs:
                contador_no_respuestas_faqs = 0  # Reiniciar el contador m√°ximo
                capacidad = f"*{nombre_usuario}* creo que mi capacidad de respuesta lleg√≥ a su l√≠mite.üíî ¬°No te preocupes! üòÅ Un asesor te contactar√° en breve para darte seguimiento. üë®üèΩ‚Äçüíª"
                send_whatsapp_message(formatted_phone_number, capacidad)
                sentimiento_global = "mandar_prospeccion"  # Cambiar la variable global para activar preguntar_por_asesor
                return capacidad

def buscar_sentimientos(ruta_archivo, message, formatted_phone_number):
    global sentimiento_global
    pos_tags = pos_tag(word_tokenize(message))
    intencion = detectar_intenciones(pos_tags, message)

    if sentimiento_global == 'agradecimiento':
        agradecimiento = "de nada"
        send_whatsapp_message(formatted_phone_number, agradecimiento)
        print("Estamos agradecidos")

    elif sentimiento_global in ['agendar_cita', 'interes_producto']:
        respuesta = agendar_cita(formatted_phone_number, message)
        print("Pasamos a preguntar asesor")

    elif sentimiento_global in ['compra', 'asesoria', 'informacion_adicional',]:
        respuesta = preguntar_por_asesor(formatted_phone_number, message)
        print("Pasamos a preguntar asesor")
    
    elif sentimiento_global == 'mandar_asesor':
        respuesta = mandar_asesor(formatted_phone_number, message)
        print("Pasamos a mandar_asesor")
    
    elif sentimiento_global == 'mandar_prospeccion':
        respuesta = mandar_prospeccion(formatted_phone_number, message)
        print("Pasamos a mandar_prospeccion")

    elif sentimiento_global == 'desinteres':
        respuesta = mandar_desinteres(formatted_phone_number, message)
        print("Pasamos a mandar_desinteres")


    else:
        if intencion == 'agradecimiento':
            agradecimiento = "de nada"
            
            send_whatsapp_message(formatted_phone_number, agradecimiento)
            print("Estamos agradecidos")

        elif intencion in ['agendar_cita', 'interes_producto']:
            pregunta_inicial = "¬øTe gustar√≠a agendar una cita? üóìÔ∏è "
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
            #respuesta = agendar_cita(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        elif intencion in ['compra', 'asesoria', 'informacion_adicional', 'asesor']:
            pregunta_inicial = f"¬øTe gustar√≠a hablar con un asesor üë®üèΩ‚Äçüíª sobre tu pr√≥xima inversi√≥n en {desarrollo_interesado} üè¢?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")
        
        elif intencion in ['compra', 'asesoria', 'informacion_adicional', 'asesor']:
            pregunta_inicial = f"¬øTe gustar√≠a hablar con un asesor üë®üèΩ‚Äçüíª sobre tu pr√≥xima inversi√≥n en {desarrollo_interesado} üè¢?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        elif intencion == 'mandar_asesor':
            sentimiento_global = intencion
            respuesta = mandar_asesor(formatted_phone_number, message)
            print("Cerrando funci√≥n mandar_asesor")

        elif intencion == 'mandar_prospeccion':
            sentimiento_global = intencion
            respuesta = mandar_prospeccion(formatted_phone_number, message)
            print("Cerrando funci√≥n mandar_prospeccion")

        elif intencion == 'desinteres':
            pregunta_inicial = f"¬øTe gustar√≠a hablar de otro de nuestros desarrollos üèóÔ∏èüèôÔ∏è?"
            send_whatsapp_message(formatted_phone_number, pregunta_inicial)
            sentimiento_global = intencion
           # respuesta = preguntar_por_asesor(formatted_phone_number )
            print("Cerrando funci√≥n contestar_faqs")

        else:
            contestar_faqs(ruta_archivo, message, formatted_phone_number)


def agendar_cita(formatted_phone_number, message):
    global sentimiento_global

    print("Iniciando funci√≥n agendar_cita")
    respuesta_cliente = message
    print("respuesta del cliente=", respuesta_cliente)

    dia_cita, hora_cita = obtener_dia_hora_cita(message)
    print("dia_cita =", dia_cita)
    print("hora_cita =", hora_cita)  # Obtener valores de dia_cita y hora_cita
 

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si", "ok"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            pedir_hora_fecha = "¬øEn que d√≠a y horario te gustar√≠a programarla? üóìÔ∏è üïê"
            #send_whatsapp_message(formatted_phone_number, pedir_hora_fecha)
            
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            #respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            ayudarte_mas = "¬øPuedo ayudarte en algo m√°s?"
            send_whatsapp_message(formatted_phone_number, ayudarte_mas)
            
            sentimiento_global = None  # Resetear sentimiento_global a None
        else:
            print("No se reconoce ninguna intenci√≥n.")

    if dia_cita is None and hora_cita is  None:
        dia_hora_agenda = "¬øEn que d√≠a y horario te gustar√≠a programarla? üóìÔ∏è üïê"
        send_whatsapp_message(formatted_phone_number, dia_hora_agenda)
        print("preguntando por d√≠a:")

    if dia_cita is None and hora_cita is not None:
        dia_agenda = "¬øQu√© d√≠a te gustar√≠a agendar?üóìÔ∏è"
        send_whatsapp_message(formatted_phone_number, dia_agenda)
        print("preguntando por d√≠a:")

    if hora_cita is None and dia_cita is not None:
        hora_agenda = "¬øA qu√© hora te gustar√≠a agendar?üïê"
        send_whatsapp_message(formatted_phone_number, hora_agenda)
        print("preguntando por hora")

    if hora_cita is not None and dia_cita is not None:
        respuesta = f"Perfecto {nombre_usuario}, un asesor se pondra en contacto contigo para confirmar tu cita para el d√≠a {dia_cita} a la(s) {hora_cita}üïê üóìÔ∏è"
        send_whatsapp_message(formatted_phone_number, respuesta)
        sentimiento_global = None  # Resetear sentimiento_global a None
        print("Agendado :3 no quiero saber nada xD")
    print("Finalizando funci√≥n agendar_cita")

def preguntar_por_asesor(formatted_phone_number, message):
    global sentimiento_global, ruta_archivo, contexto, contexto_global, desarrollo_interesado  # Declarar que se utilizar√° la variable global

    print("Iniciando funci√≥n preguntar_por_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias por tu inter√©s! Un asesor se pondr√° en contacto contigo prontoüë®üèΩ‚Äçüíª"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            #respuesta = preguntar_por_asesor(ruta_archivo, formatted_phone_number, message)
            respuesta = "¬øTe gustar√≠a recibir informaci√≥n de alg√∫n otro desarrollo? Invierte en preventa enüìçZona Centro Hist√≥rico üìçZona MinervaüìçZona Chapu üìçZona Barranca"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            # Resetear sentimiento_global a None
            sentimiento_global = None
            ruta_archivo = None  
            contexto = None
            contexto_global = None
            desarrollo_interesado = None
            
    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n preguntar_por_asesor")

def mandar_desinteres(formatted_phone_number, message):
    global sentimiento_global, ruta_archivo, contexto, contexto_global, desarrollo_interesado  # Declarar que se utilizar√° la variable global

    print("Iniciando funci√≥n preguntar_por_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            verificacion = f"*{nombre_usuario}* üåü ¬øDe qu√© desarrollo te gustar√≠a recibir informaci√≥n? üè¢  \n\nSi no conoces el nombre del desarrollo, puedes preguntarme porüìçubicaciones cercanas o üí∞rangos de precio."
            send_whatsapp_message(formatted_phone_number, verificacion)
            print("Respuesta positiva enviada:", verificacion)
            sentimiento_global = None
            ruta_archivo = None  
            contexto = None
            contexto_global = None
            desarrollo_interesado = None
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
                        #respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            ayudarte_mas = "¬øEn que m√°s te puedo ayudar?"
            send_whatsapp_message(formatted_phone_number, ayudarte_mas)
            
            sentimiento_global = None  # Resetear sentimiento_global a None
            
    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n preguntar_por_asesor")

def mandar_asesor (formatted_phone_number, message):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    print("Iniciando funci√≥n mandar_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias por tu inter√©s! üë®üèΩ‚Äçüíª Un asesor se pondr√° en contacto contigo pronto."
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            respuesta = "¬øEn qu√© m√°s puedo ayudarte?"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            sentimiento_global = None  # Resetear sentimiento_global a None

    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n mandar_asesor")

def mandar_prospeccion (formatted_phone_number, message):
    global sentimiento_global  # Declarar que se utilizar√° la variable global
    print("Iniciando funci√≥n mandar_asesor")
    
    respuesta_cliente = None
    respuesta_cliente= message
    print("respuesta del cliente=", respuesta_cliente)

    palabras_clave_positivas = ["s√≠", "claro", "me interesa", "me gustar√≠a", "si"]
    palabras_clave_negativas = ["no", "no estoy interesado", "no me interesa"]

    if respuesta_cliente is not None:
        if any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_positivas):
            respuesta = "¬°Gracias! prospecci√≥n se pondr√° en contacto contigo pronto."
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta positiva enviada:", respuesta)
        elif any(palabra in respuesta_cliente.lower() for palabra in palabras_clave_negativas):
            respuesta = contestar_faqs(ruta_archivo, respuesta_cliente, formatted_phone_number)
            respuesta = "Lamentamos no poder ayudarte üò≠üò≠"
            send_whatsapp_message(formatted_phone_number, respuesta)
            print("Respuesta negativa enviada:", respuesta)
            sentimiento_global = None  # Resetear sentimiento_global a None

    else:
        print("La respuesta del cliente es None, no se pueden realizar comprobaciones.")

    print("Finalizando funci√≥n mandar_asesor")

    
def generar_respuesta_chatgpt(message, respuesta_encontrada):

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"{respuesta_encontrada} \n\n{message} "
    print("ChatGPT est√° procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompt,
        temperature=1,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada

def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un n√∫mero de tel√©fono de WhatsApp v√°lido
        body=message,
        to='whatsapp:+5213328650226'  # N√∫mero de tel√©fono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)