from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse




load_dotenv()

# Crear la aplicación Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en español fuera de la función
nlp_model = spacy.load('es_core_news_sm')

# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como parámetro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def detectar_intenciones(pos_tags, message):
    # Realizar análisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    # Realizar análisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intención del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'

    return intencion


def generar_respuesta(intencion, ultimo_mensaje_cliente):
    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_botón = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, envíanos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_botón}"
    return respuesta

def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como parámetro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Función para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminación de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords


# Función para verificar si un nombre de desarrollo es válido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Función para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos días', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Función para obtener el desarrollo de interés mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None


# Función para verificar si un mensaje menciona información del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aquí se asume que los nombres se componen de palabras que comienzan con una letra mayúscula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0

# Función para obtener la faq correspondiente a un desarrollo de interés
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

# Variables globales para almacenar la información del usuario
nombre_usuario = None
numero_telefono = None
ruta_archivo = None
desarrollo_interesado = None

# Función para guardar la información del usuario en variables
def guardar_informacion_usuario(nombre, telefono, archivo):
    global nombre_usuario, numero_telefono, ruta_archivo
    nombre_usuario = nombre
    numero_telefono = telefono
    ruta_archivo = archivo

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if nombre_usuario is not None and desarrollo_interesado is not None and ruta_archivo is not None:
        # Llamar directamente a la función contestar_faqs
        respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento


        
    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        # Obtener el contexto del desarrollo mencionado
        contexto, ruta_archivo = obtener_contexto(message)  # Se utiliza solo el valor del contexto, se ignora la ruta de archivo

        if nombre_usuario and contexto:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

        elif contexto:
            # Construir el mensaje de saludo solo con el contexto
            mensaje_saludo = f"{saludo}! {contexto}."
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Seleccionar una forma de manera aleatoria para solicitar el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)

            # Enviar el mensaje solicitando el nombre del cliente
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

        else:
            # No se encontró el nombre del cliente ni el contexto, no se puede construir el mensaje de saludo
            mensaje_saludo = None

        # Verificar si se ha guardado la información del usuario previamente
        if nombre_usuario is None:
            # Guardar la información del usuario en variables
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado)

        if nombre_usuario and ruta_archivo:
            respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
            print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
            # Cerrar el ciclo actual y solicitar más información si es necesario
            send_whatsapp_message(formatted_phone_number, f"{nombre_usuario}, ¿cómo te puedo apoyar hoy?")
            return "OK"

    # Si no se cumplen los criterios anteriores, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, f"No se están cumpliendo los criterios, ruta_archivo = {ruta_archivo}")
    return "OK"


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo Python correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Buscar preguntas similares y obtener la respuesta correspondiente
        respuesta_encontrada = None  # Variable para guardar la respuesta encontrada
        link_encontrado = None  # Variable para guardar el enlace encontrado

        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuesta = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuesta
                    print("Respuesta encontrada:", respuesta)

                    # Verificar si la respuesta contiene un enlace
                    if "http" in respuesta:
                        link_encontrado = respuesta
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el mensaje con el enlace encontrado
            send_whatsapp_message(formatted_phone_number, link_encontrado)
            link_encontrado = None  # Reiniciar la variable link_encontrado

        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            print("Esta respuesta es generada por ChatGpt:", respuesta_chatgpt)
            return respuesta_chatgpt

        # Si no se encontraron coincidencias, devolver un mensaje de respuesta por defecto
        return "Lo siento, no puedo responder a esa pregunta en este momento."



def generar_respuesta_chatgpt(message, respuesta_encontrada):
    # Establecer los parámetros para generar la respuesta con ChatGPT
    max_tokens = 100  # Número máximo de tokens para la respuesta generada
    temperature = 0.5  # Controla la aleatoriedad de las respuestas generadas

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"No saludar, actúa como vendedor inmobiliario, solo parafrasea la respuesta para que sea coherente, agrega emojis\nCliente: {message}\nRespuesta encontrada: {respuesta_encontrada}\n"
    print("ChatGPT esta procesando los Datos ")
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=prompt,
        temperature=temperature,
        max_tokens=max_tokens,
        n=1,
        stop=None,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada


"""     if response.choices and len(response.choices) > 0:
            answer = response.choices[0].text.strip()
            message_with_emoji = assign_emojis(answer)
            return message_with_emoji
        else:
            return 'Lo siento, no tengo información sobre ese tema en particular. ¿Hay algo más en lo que pueda ayudarte?'
"""


def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un número de teléfono de WhatsApp válido
        body=message,
        to='whatsapp:+5213328650226'  # Número de teléfono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)





   # Alpha 2.01   <----------------------------------------------------------------------------------> <------------------------------------>

   from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse




load_dotenv()

# Crear la aplicación Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en español fuera de la función
nlp_model = spacy.load('es_core_news_sm')

# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como parámetro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def detectar_intenciones(pos_tags, message):
    # Realizar análisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    # Realizar análisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intención del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'

    return intencion


def generar_respuesta(intencion, ultimo_mensaje_cliente):
    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_botón = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, envíanos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_botón}"
    return respuesta

def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como parámetro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Función para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminación de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords


# Función para verificar si un nombre de desarrollo es válido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Función para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos días', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Función para obtener el desarrollo de interés mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None


# Función para verificar si un mensaje menciona información del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aquí se asume que los nombres se componen de palabras que comienzan con una letra mayúscula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0

# Función para obtener la faq correspondiente a un desarrollo de interés
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

# Variables globales para almacenar la información del usuario
nombre_usuario = None
numero_telefono = None
ruta_archivo = None
desarrollo_interesado = None

# Función para guardar la información del usuario en variables
def guardar_informacion_usuario(nombre, telefono, archivo):
    global nombre_usuario, numero_telefono, ruta_archivo
    nombre_usuario = nombre
    numero_telefono = telefono
    ruta_archivo = archivo

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if nombre_usuario is not None and desarrollo_interesado is not None and ruta_archivo is not None:
        # Llamar directamente a la función contestar_faqs
        respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento


        
    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        # Obtener el contexto del desarrollo mencionado
        contexto, ruta_archivo = obtener_contexto(message)  # Se utiliza solo el valor del contexto, se ignora la ruta de archivo

        if nombre_usuario and contexto:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

        elif contexto:
            # Construir el mensaje de saludo solo con el contexto
            mensaje_saludo = f"{saludo}! {contexto}."
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Seleccionar una forma de manera aleatoria para solicitar el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)

            # Enviar el mensaje solicitando el nombre del cliente
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

        else:
            # No se encontró el nombre del cliente ni el contexto, no se puede construir el mensaje de saludo
            mensaje_saludo = None

        # Verificar si se ha guardado la información del usuario previamente
        if nombre_usuario is None:
            # Guardar la información del usuario en variables
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado)

        if nombre_usuario and ruta_archivo:
            respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
            print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
            # Cerrar el ciclo actual y solicitar más información si es necesario
            send_whatsapp_message(formatted_phone_number, f"{nombre_usuario}, ¿cómo te puedo apoyar hoy?")
            return "OK"

    # Si no se cumplen los criterios anteriores, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, f"No se están cumpliendo los criterios, ruta_archivo = {ruta_archivo}")
    return "OK"


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)

        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            print("Esta respuesta es generada por ChatGpt:", respuesta_chatgpt)
            return respuesta_chatgpt

        # Si no se encontró ninguna respuesta válida y no se encontró ningún enlace
        return "Lo siento, no puedo responder a esa pregunta en este momento."


def generar_respuesta_chatgpt(message, respuesta_encontrada):
    # Establecer los parámetros para generar la respuesta con ChatGPT
    max_tokens = 100  # Número máximo de tokens para la respuesta generada
    temperature = 0.8  # Controla la aleatoriedad de las respuestas generadas

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"No saludes, actúa como vendedor inmobiliario, solo parafrasea la Respuesta encontrada para que sea coherentea, agrega emojis\nCliente: {message}\nRespuesta encontrada: {respuesta_encontrada}"
    print("ChatGPT está procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=prompt,
        temperature=temperature,
        max_tokens=max_tokens,
        n=1,
        stop=None,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada


def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un número de teléfono de WhatsApp válido
        body=message,
        to='whatsapp:+5213328650226'  # Número de teléfono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)





    <--------------------------------------------------------------><>>>>>>>>>>><<<<<<<    <--------------------------------------------------------------><>>>>>>>>>>><<<<<<<
from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse




load_dotenv()

# Crear la aplicación Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en español fuera de la función
nlp_model = spacy.load('es_core_news_sm')

# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como parámetro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def detectar_intenciones(pos_tags, message):
    # Realizar análisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    # Realizar análisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intención del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'

    return intencion


def generar_respuesta(intencion, ultimo_mensaje_cliente):
    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_botón = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, envíanos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_botón}"
    return respuesta

def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como parámetro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Función para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminación de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords


# Función para verificar si un nombre de desarrollo es válido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Función para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos días', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Función para obtener el desarrollo de interés mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None


# Función para verificar si un mensaje menciona información del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aquí se asume que los nombres se componen de palabras que comienzan con una letra mayúscula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0

# Función para obtener la faq correspondiente a un desarrollo de interés
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

# Variables globales para almacenar la información del usuario
nombre_usuario = None
numero_telefono = None
ruta_archivo = None
desarrollo_interesado = None

# Función para guardar la información del usuario en variables
def guardar_informacion_usuario(nombre, telefono, archivo):
    global nombre_usuario, numero_telefono, ruta_archivo
    nombre_usuario = nombre
    numero_telefono = telefono
    ruta_archivo = archivo

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if nombre_usuario is not None and desarrollo_interesado is not None and ruta_archivo is not None:
        # Llamar directamente a la función contestar_faqs
        respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento


        
    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        # Obtener el contexto del desarrollo mencionado
        contexto, ruta_archivo = obtener_contexto(message)  # Se utiliza solo el valor del contexto, se ignora la ruta de archivo

        if nombre_usuario and contexto:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

        elif contexto:
            # Construir el mensaje de saludo solo con el contexto
            mensaje_saludo = f"{saludo}! {contexto}."
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Seleccionar una forma de manera aleatoria para solicitar el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)

            # Enviar el mensaje solicitando el nombre del cliente
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

        else:
            # No se encontró el nombre del cliente ni el contexto, no se puede construir el mensaje de saludo
            mensaje_saludo = None

        # Verificar si se ha guardado la información del usuario previamente
        if nombre_usuario is None:
            # Guardar la información del usuario en variables
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado)

        if nombre_usuario and ruta_archivo:
            respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
            print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
            # Cerrar el ciclo actual y solicitar más información si es necesario
            send_whatsapp_message(formatted_phone_number, f"{nombre_usuario}, ¿cómo te puedo apoyar hoy?")
            return "OK"

    # Si no se cumplen los criterios anteriores, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, f"No se están cumpliendo los criterios, ruta_archivo = {ruta_archivo}")
    return "OK"


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)

        if respuesta_encontrada:
            # Generar respuesta coherente con SpaCy
            respuesta_generada = generar_respuesta_spacy(message, respuesta_encontrada)
            print("Esta respuesta es generada por SpaCy:", respuesta_generada)
            return respuesta_generada

        # Si no se encontró ninguna respuesta válida y no se encontró ningún enlace
        return "Lo siento, no puedo responder a esa pregunta en este momento."


def generar_respuesta_spacy(pregunta_cliente, respuesta_encontrada):
    nlp = spacy.load("es_core_news_sm")
    pregunta = nlp(pregunta_cliente)
    respuesta = nlp(respuesta_encontrada)

    # Realizar cualquier procesamiento adicional necesario en la respuesta utilizando SpaCy

    respuesta_generada = ' '.join([token.text for token in respuesta])  # Convertir la respuesta procesada de SpaCy a texto

    return respuesta_generada



def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un número de teléfono de WhatsApp válido
        body=message,
        to='whatsapp:+5213328650226'  # Número de teléfono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)





    <<<<<<<<------------------------------------->>>>>>>>>><<<<<<<<<<<<------------------------------>>>>>>>>


"""


def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)

        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            print("Esta respuesta es generada por ChatGpt:", respuesta_chatgpt)
            return respuesta_chatgpt

        # Si no se encontró ninguna respuesta válida y no se encontró ningún enlace
        return "Lo siento, no puedo responder a esa pregunta en este momento."


def generar_respuesta_chatgpt(message, respuesta_encontrada):
    # Establecer los parámetros para generar la respuesta con ChatGPT
    max_tokens = 100  # Número máximo de tokens para la respuesta generada
    temperature = 1  # Controla la aleatoriedad de las respuestas generadas

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"No saludes, actúa como vendedor inmobiliario, ofrece la mejor respuesta a la pregunta del cliente, agrega emojis\nCliente: {message}\nRespuesta encontrada: {respuesta_encontrada}"
    print("ChatGPT está procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=prompt,
        temperature=temperature,
        max_tokens=max_tokens,
        n=1,
        stop=None,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada
"""





__________________________________>>>>>>>>>>>>>><<<<<<<<<<<<<<__________________________________
from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY, PIPEDRIVE_API_KEY
from flask import Flask, request
from twilio.rest import Client
import pipedrive
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse
import requests
import os
import openai
import requests






load_dotenv()

# Crear la aplicación Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en español fuera de la función
nlp_model = spacy.load('es_core_news_lg')

# Definir variables y configuraciones
pipedrive_key = PIPEDRIVE_API_KEY
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como parámetro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def detectar_intenciones(pos_tags, message):
    # Realizar análisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    # Realizar análisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intención del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'

    return intencion


def generar_respuesta(intencion, ultimo_mensaje_cliente):
    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_botón = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, envíanos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_botón}"
    return respuesta

def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como parámetro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Función para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminación de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords


# Función para verificar si un nombre de desarrollo es válido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False

# Función para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos días', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if nombre_desarrollo_valido(desarrollo['nombre']) and desarrollo['nombre'].lower() in message.lower():
                    return True
    return False


# Función para obtener el desarrollo de interés mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None


# Función para verificar si un mensaje menciona información del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aquí se asume que los nombres se componen de palabras que comienzan con una letra mayúscula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0

# Función para obtener la faq correspondiente a un desarrollo de interés
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

# Variables globales para almacenar la información del usuario
nombre_usuario = None
print(f"variable_nombre: {nombre_usuario}")
numero_telefono = None
print(f"variable_telefono: {numero_telefono}")
ruta_archivo = None
print(f"variable_ruta: {ruta_archivo}")
desarrollo_interesado = None
print(f"variable_desarrollo: {desarrollo_interesado}")


# Diccionario que mapea las rutas de archivo a los nombres de desarrollos correspondientes
desarrollo_interesado_map = {
    'faq_desarrollos/faq_Soneto.json': 'Soneto',
    'faq_desarrollos/faq_Maria_jose.json': 'Maria Jose',
    'faq_desarrollos/faq_kartesia.json': 'Kartesia'
}
# Diccionario que mapea el nombre del desarrollo al ID del embudo en Pipedrive
embudos_map = {
    'Soneto': 3,  # Reemplaza 3 con el ID del embudo correspondiente en Pipedrive
    'Maria Jose': 2,  # Reemplaza 2 con el ID del embudo correspondiente en Pipedrive
    'Kartesia': 1,  # Reemplaza 1 con el ID del embudo correspondiente en Pipedrive
    # Agrega más desarrollos y sus respectivos IDs de embudos aquí
}




@app.route('/whatsapp', methods=['POST'])
@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        if desarrollo_interesado and nombre_usuario:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {desarrollo_interesado['contexto']}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Guardar la información del cliente y desarrollo de interés
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado['nombre'])

            # Preguntar por el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

            # Guardar la ruta del archivo para la faq del desarrollo de interés
            ruta_archivo = desarrollo_interesado['ruta_archivo']

            return "OK"

    # Si el mensaje contiene solo un saludo, preguntar por el desarrollo de interés
    if mensaje_es_saludo_con_desarrollo(message):
        solicitud_desarrollo = "¡Hola! ¿Qué desarrollo te interesa? Por favor, proporciona el nombre del desarrollo o un modelo específico."
        send_whatsapp_message(formatted_phone_number, solicitud_desarrollo)
        return "OK"

    # Si el mensaje no contiene información del cliente ni un saludo con desarrollo, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, "No se detectó información relevante en tu mensaje.")
    return "OK"




def guardar_informacion_usuario(nombre, telefono, archivo, desarrollo):
    global nombre_usuario, numero_telefono, ruta_archivo, desarrollo_interesado
    nombre_usuario = nombre
    numero_telefono = telefono
    ruta_archivo = desarrollo
    desarrollo_interesado =  desarrollo

    # Impresión de las variables después de asignarles valor
    print(f"Nombre de usuario: {nombre_usuario}")
    print(f"Número de teléfono: {numero_telefono}")
    print(f"Ruta del archivo: {ruta_archivo}")
    print(f"Desarrollo interesado: {desarrollo_interesado}")

    # Obtener el nombre del desarrollo basado en la ruta de archivo y actualizar desarrollo_interesado
    desarrollo_interesado = desarrollo_interesado_map.get(desarrollo, desarrollo_interesado)

    print(f"Desarrollo después de la actualización: {desarrollo_interesado}")

    # Verificar si el desarrollo está mapeado a un embudo en Pipedrive
    embudo_id = embudos_map.get(desarrollo_interesado)

    if embudo_id is not None:
        # Enviar la información a la API de Pipedrive
        # ... (código para enviar la información a Pipedrive, como se mostró en la respuesta anterior)
        # Aquí también puedes incluir el ID del embudo en el payload para crear el trato en el embudo adecuado.
        print(f"La información se enviará a Pipedrive con el ID de embudo: {embudo_id}")
    else:
        print(f'El desarrollo {desarrollo_interesado} no está mapeado a un embudo en Pipedrive. La información no se guardará.')


url_pipedrive_api = 'https://api.pipedrive.com/v1/deals'
payload = {
    'title': f'{nombre_usuario} - {desarrollo_interesado}',  # Título del trato en Pipedrive
    'value': 0,  # Valor del trato, puedes ajustarlo según tus necesidades
    'status': 'open',  # Estado del trato (abierto)
    'person_name': nombre_usuario,  # Nombre de la persona asociada al trato
    'phone': numero_telefono,  # Número de teléfono de la persona asociada al trato
    'deal_source': 'WhatsApp',  # Origen del trato (WhatsApp)
    'note': f'Interesado en el desarrollo {desarrollo_interesado}',  # Nota asociada al trato
}
headers = {
    'Authorization': f'Bearer {PIPEDRIVE_API_KEY}',  # Incluir la clave de API en los encabezados de la solicitud
    'Content-Type': 'application/json',
}
try:
    response = requests.post(url_pipedrive_api, json=payload, headers=headers)
    response_data = response.json()
    if response.status_code == 201:
        print('Información enviada a Pipedrive exitosamente.')
    else:
        print('Error al enviar la información a Pipedrive.')
        print('Detalles del error:', response_data)
except Exception as e:
    print('Error al enviar la información a Pipedrive:', e)
    print('Detalles del error:', response_data)





def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)

        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            print("Esta respuesta es generada por ChatGpt:", respuesta_chatgpt)
            return respuesta_chatgpt

        # Si no se encontró ninguna respuesta válida y no se encontró ningún enlace
        return "Lo siento, no puedo responder a esa pregunta en este momento."

"""
def generar_respuesta_chatgpt(message, respuesta_encontrada):

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"{respuesta_encontrada} \n\n{message} "
    print("ChatGPT está procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompt,
        temperature=1,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada
"""

def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un número de teléfono de WhatsApp válido
        body=message,
        to='whatsapp:+5213328650226'  # Número de teléfono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)




___________________>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<>_______________________-----------<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>><<



def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if nombre_usuario is not None and desarrollo_interesado is not None and ruta_archivo is not None:
        # Llamar directamente a la función contestar_faqs
        respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento


        
    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        # Obtener el contexto del desarrollo mencionado
        contexto, ruta_archivo = obtener_contexto(message)  # Se utiliza solo el valor del contexto, se ignora la ruta de archivo

        if nombre_usuario and contexto:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

        elif contexto:
            # Construir el mensaje de saludo solo con el contexto
            mensaje_saludo = f"{saludo}! {contexto}."
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Seleccionar una forma de manera aleatoria para solicitar el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)

            # Enviar el mensaje solicitando el nombre del cliente
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

        else:
            # No se encontró el nombre del cliente ni el contexto, no se puede construir el mensaje de saludo
            mensaje_saludo = None

        if nombre_usuario and ruta_archivo:
            respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
            print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
            # Cerrar el ciclo actual y solicitar más información si es necesario
            send_whatsapp_message(formatted_phone_number, f"{nombre_usuario}, ¿cómo te puedo apoyar hoy?")
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado)
            return "OK"

    # Si no se cumplen los criterios anteriores, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, f"No se están cumpliendo los criterios, ruta_archivo = {ruta_archivo}")
    return "OK"


________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

   """ Estrctura basica funcional sin   pipedrive y logicas de caso y envios ya tiene conexion con GPT3  """

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________



from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, OPENAI_API_KEY
from flask import Flask, request
from twilio.rest import Client
import openai
import spacy
from dotenv import load_dotenv
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.sentiment import SentimentIntensityAnalyzer
from nltk.stem import WordNetLemmatizer
from emoji import assign_emojis
from datos_desarrollos import obtener_contexto
from faq_desarrollos import faq_DyG
from property_data import property_data
from phone_utils import process_phone_number
from zapier_utils import send_to_zapier
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
import nltk.data
from flask import Flask, request, jsonify
import random
from spacy.lang.es.stop_words import STOP_WORDS
from solicitudes_nombre import formas_solicitud_nombre
from saludos import obtener_saludo
import random
from nltk import ne_chunk, pos_tag, word_tokenize
from nltk.tree import Tree
import datos_desarrollos
import json
import re
import urllib.parse




load_dotenv()

# Crear la aplicación Flask
app = Flask(__name__)

# Cargar el modelo de spaCy para NER en español fuera de la función
nlp_model = spacy.load('es_core_news_lg')

# Definir variables y configuraciones
client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
sia = SentimentIntensityAnalyzer()
lemmatizer = WordNetLemmatizer()

desarrollos = datos_desarrollos.desarrollos

def extract_entities(message, nlp_model):
    # Procesar el mensaje con el modelo de spaCy pasado como parámetro
    doc = nlp_model(message)

    # Obtener las entidades nombradas detalladas del mensaje
    named_entities = []
    for ent in doc.ents:
        named_entities.append({
            'text': ent.text,
            'start': ent.start_char,
            'end': ent.end_char,
            'label': ent.label_,
            'lemma': ent.lemma_
        })
    return named_entities

def preprocesar_mensaje(message):
    tokens = word_tokenize(message)
    pos_tags = pos_tag(tokens)
    return pos_tags


def detectar_intenciones(pos_tags, message):
    # Realizar análisis de sentimiento
    sia = SentimentIntensityAnalyzer()
    sentiment_scores = sia.polarity_scores(message)
    sentiment_score = sentiment_scores['compound']

    # Realizar análisis de entidades nombradas
    doc = nlp_model(message)
    named_entities = [ent.text for ent in doc.ents]

    # Determinar la intención del cliente
    intencion = None  # Asignar un valor predeterminado a la variable intencion

    if sentiment_score <= -0.05:
        intencion = 'queja'

    return intencion


def generar_respuesta(intencion, ultimo_mensaje_cliente):
    if intencion == 'queja':
        mensaje_cliente_encoded = urllib.parse.quote(ultimo_mensaje_cliente)
        texto_resaltado = "*Reclamo abierto:*"
        texto_resaltado_encoded = urllib.parse.quote(texto_resaltado)
        enlace_botón = f"https://api.whatsapp.com/send?phone=+523310678076&text={texto_resaltado_encoded}%0A{mensaje_cliente_encoded}"
        respuesta = f"Lamentamos escuchar eso. Por favor, envíanos los detalles de tu queja y nos pondremos en contacto contigo lo antes posible. Puedes hacer clic en el siguiente enlace para abrir WhatsApp y contactar al departamento de Calidad.\n\n{texto_resaltado}\n{enlace_botón}"
    return respuesta

def extract_message_data(message, nlp_model):
    names = []

    # Aplicar el modelo de spaCy al mensaje utilizando el modelo pasado como parámetro
    doc = nlp_model(message)

    # Extraer las entidades nombradas relevantes del documento
    for entity in doc.ents:
        if entity.label_ in ["PER", "PERS", "ORG"]:
            names.append(entity.text)

    return names

# Función para detectar palabras clave en un mensaje
def detect_keywords(message, nlp_model):
    # Preprocesamiento adicional si es necesario (por ejemplo, eliminación de stopwords)

    # Tokenizar el mensaje
    doc = nlp_model(message)

    # Obtener las palabras clave (sustantivos, adjetivos, verbos, nombres propios, etc.)
    keywords = [token.lemma_ for token in doc if token.pos_ in ['NOUN', 'ADJ']]

    return keywords


# Función para verificar si un nombre de desarrollo es válido
def nombre_desarrollo_valido(nombre):
    for desarrollo in desarrollos:
        if isinstance(desarrollo['nombre'], list):
            if any(variante.lower() == nombre.lower() for variante in desarrollo['nombre']):
                return True
        else:
            if nombre.lower() == desarrollo['nombre'].lower():
                return True
    return False
# Función para verificar si un mensaje contiene un saludo junto con el nombre de un desarrollo
def mensaje_es_saludo_con_desarrollo(message):
    saludos = ['hola', 'buenos días', 'buenas tardes', 'buenas noches']
    for saludo in saludos:
        if saludo in message.lower():
            for desarrollo in desarrollos:
                if desarrollo['nombre'].lower() in message.lower():
                    return True
    return False

# Función para obtener el desarrollo de interés mencionado en un mensaje
def obtener_desarrollo_interesado(message):
    for desarrollo in desarrollos:
        if any(variante.lower() in message.lower() for variante in desarrollo['nombre']):
            return desarrollo

    return None


# Función para verificar si un mensaje menciona información del cliente
def menciona_informacion_cliente(message):
    # Utilizar expresiones regulares para detectar nombres
    # Aquí se asume que los nombres se componen de palabras que comienzan con una letra mayúscula
    pattern = re.compile(r'\b[A-Z][a-z]*\b')
    matches = pattern.findall(message)
    return len(matches) > 0

# Función para obtener la faq correspondiente a un desarrollo de interés
def obtener_faq_desarrollo(desarrollo_interesado):
    for desarrollo in desarrollos:
        if desarrollo['nombre'] == desarrollo_interesado:
            return desarrollo['nombre']

    return None

def buscar_pregunta_similar(preguntas, entidades_nombradas, tokens_importantes):
    preguntas_similares = []
    
    for pregunta in preguntas:
        pregunta_actual = pregunta['preguntas']
        
        # Verificar si la pregunta contiene al menos una entidad nombrada similar
        entidades_nombradas_pregunta = extract_entities(pregunta_actual, nlp_model)
        entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]
        
        # Verificar si la pregunta contiene al menos un token importante
        tokens_pregunta = detect_keywords(pregunta_actual, nlp_model)
        tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]
        
        # Si la pregunta tiene entidades similares o tokens similares, agregarla a las preguntas similares
        if entidades_similares or tokens_similares:
            preguntas_similares.append(pregunta_actual)
    
    return preguntas_similares

# Variables globales para almacenar la información del usuario
nombre_usuario = None
numero_telefono = None
ruta_archivo = None
desarrollo_interesado = None

# Función para guardar la información del usuario en variables
def guardar_informacion_usuario(nombre, telefono, archivo):
    global nombre_usuario, numero_telefono, ruta_archivo
    nombre_usuario = nombre
    numero_telefono = telefono
    ruta_archivo = archivo

@app.route('/whatsapp', methods=['POST'])
def process_message():
    global nombre_usuario, desarrollo_interesado, ruta_archivo

    # Obtener el mensaje y el número de teléfono del remitente
    message = request.form.get('Body')
    formatted_phone_number = process_phone_number(request.form.get('From'))

    # Verificar si el mensaje contiene una queja
    pos_tags = pos_tag(word_tokenize(message))
    if detectar_intenciones(pos_tags, message) == 'queja':
        respuesta = generar_respuesta('queja', message)  # Generar una respuesta correspondiente a la queja
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"

    # Continuar con el proceso si no es una queja

    if nombre_usuario is not None and desarrollo_interesado is not None and ruta_archivo is not None:
        # Llamar directamente a la función contestar_faqs
        respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
        send_whatsapp_message(formatted_phone_number, respuesta)
        return "OK"


    # Detección de palabras clave y extracción de entidades
    keywords = detect_keywords(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    entities = extract_entities(message, nlp_model)  # Pasar el modelo de spaCy como argumento
    names = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento


        
    # Obtener el saludo según la hora actual
    saludo = obtener_saludo()

    # Verificar si el mensaje menciona información del cliente
    if menciona_informacion_cliente(message):
        nombres_entidades = extract_message_data(message, nlp_model)  # Pasar el modelo de spaCy como argumento

        # Filtrar los nombres de entidades que no sean similares a nombres o modelos de desarrollos
        nombres_filtrados = []
        for nombre in nombres_entidades:
            if not nombre_desarrollo_valido(nombre):
                nombres_filtrados.append(nombre)

        nombre_usuario = nombres_filtrados[0] if nombres_filtrados else None

        # Obtener el desarrollo mencionado en el mensaje
        desarrollo_interesado = obtener_desarrollo_interesado(message)

        # Obtener el contexto del desarrollo mencionado
        contexto, ruta_archivo = obtener_contexto(message)  # Se utiliza solo el valor del contexto, se ignora la ruta de archivo

        if nombre_usuario and contexto:
            # Construir el mensaje de saludo junto con el nombre del cliente y el contexto
            mensaje_saludo = f"{saludo} {nombre_usuario}! {contexto}"
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

        elif contexto:
            # Construir el mensaje de saludo solo con el contexto
            mensaje_saludo = f"{saludo}! {contexto}."
            send_whatsapp_message(formatted_phone_number, mensaje_saludo)

            # Seleccionar una forma de manera aleatoria para solicitar el nombre del cliente
            solicitud_nombre = random.choice(formas_solicitud_nombre)

            # Enviar el mensaje solicitando el nombre del cliente
            send_whatsapp_message(formatted_phone_number, solicitud_nombre)

        else:
            # No se encontró el nombre del cliente ni el contexto, no se puede construir el mensaje de saludo
            mensaje_saludo = None

        # Verificar si se ha guardado la información del usuario previamente
        if nombre_usuario is None:
            # Guardar la información del usuario en variables
            guardar_informacion_usuario(nombre_usuario, formatted_phone_number, desarrollo_interesado)

        if nombre_usuario and ruta_archivo:
            respuesta = contestar_faqs(ruta_archivo, message, formatted_phone_number)
            print(f"Ruta del archivo recibida 1: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento
            # Cerrar el ciclo actual y solicitar más información si es necesario
            send_whatsapp_message(formatted_phone_number, f"{nombre_usuario}, ¿cómo te puedo apoyar hoy?")
            return "OK"

    # Si no se cumplen los criterios anteriores, enviar un mensaje de error
    send_whatsapp_message(formatted_phone_number, f"No se están cumpliendo los criterios, ruta_archivo = {ruta_archivo}")
    return "OK"





def contestar_faqs(ruta_archivo, message, formatted_phone_number):
    print(f"Ruta del archivo recibida 2: {ruta_archivo}")  # Imprimir la ruta del archivo recibida como argumento

    # Abrir el archivo JSON correspondiente usando la ruta almacenada en 'ruta_archivo'
    with open(ruta_archivo, 'r') as file:
        contenido = file.read()

        # Cargar el contenido como una lista de diccionarios utilizando json.loads()
        preguntas_respuestas = json.loads(contenido)

        # Definir las entidades nombradas y tokens importantes del mensaje
        entidades_nombradas = extract_entities(message, nlp_model)
        tokens_importantes = detect_keywords(message, nlp_model)

        # Variables para guardar la respuesta encontrada y el enlace encontrado
        respuesta_encontrada = None
        link_encontrado = None

        # Buscar preguntas similares y obtener las respuestas correspondientes
        for item in preguntas_respuestas:
            preguntas = item['preguntas']
            respuestas = item['respuesta']

            # Verificar si alguna de las preguntas tiene entidades o tokens similares
            for pregunta in preguntas:
                entidades_nombradas_pregunta = extract_entities(pregunta, nlp_model)
                entidades_similares = [entidad for entidad in entidades_nombradas if entidad in entidades_nombradas_pregunta]

                tokens_pregunta = detect_keywords(pregunta, nlp_model)
                tokens_similares = [token for token in tokens_importantes if token in tokens_pregunta]

                # Si la pregunta tiene entidades o tokens similares, guardar la respuesta
                if entidades_similares or tokens_similares:
                    respuesta_encontrada = respuestas
                    print("Respuesta encontrada:", respuesta_encontrada)

                    # Verificar si hay un enlace asociado
                    if 'link' in item:
                        link_encontrado = item['link']
                        print("Enlace encontrado:", link_encontrado)

                    break

            if respuesta_encontrada:
                break

        if link_encontrado:
            # Enviar el enlace encontrado al cliente
            send_whatsapp_message(formatted_phone_number, link_encontrado)

        if respuesta_encontrada:
            # Generar respuesta coherente con ChatGPT utilizando la respuesta encontrada
            respuesta_chatgpt = generar_respuesta_chatgpt(message, respuesta_encontrada)
            print("Esta respuesta es generada por ChatGpt:", respuesta_chatgpt)
            return respuesta_chatgpt

        # Si no se encontró ninguna respuesta válida y no se encontró ningún enlace
        return "Lo siento, no puedo responder a esa pregunta en este momento."


def generar_respuesta_chatgpt(message, respuesta_encontrada):

    # Concatenar la pregunta y la respuesta encontrada como prompt para ChatGPT
    prompt = f"{respuesta_encontrada} \n\n{message} "
    print("ChatGPT está procesando los Datos:", prompt)
    # Generar respuesta con ChatGPT
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompt,
        temperature=1,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        api_key=OPENAI_API_KEY
    )

    # Obtener la respuesta generada por ChatGPT
    respuesta_generada = response.choices[0].text.strip()

    return respuesta_generada

def send_whatsapp_message(to, message):
    client.messages.create(
        from_=TWILIO_PHONE_NUMBER,  # Debe ser un número de teléfono de WhatsApp válido
        body=message,
        to='whatsapp:+5213328650226'  # Número de teléfono del destinatario
)
if __name__ == '__main__':
    app.run(port=65535)